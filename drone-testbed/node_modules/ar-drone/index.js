// Proxy mock: quando criado, conecta-se ao server via WebSocket e encaminha
// telemetry/ navdata recebida para os listeners do client. Comandos sÃ£o
// enviados ao servidor para serem aplicados no simulator (externo ou interno).
const EventEmitter = require('events');
const WebSocket = require('ws');

class ProxyClient extends EventEmitter {
  constructor() {
    super();
    this.ws = null;
    this.connected = false;
    this._connect();
  }

  _connect() {
    const url = process.env.SIM_SERVER_WS || 'ws://localhost:3001';
    this.ws = new WebSocket(url);
    this.ws.on('open', () => { this.connected = true; if (process.env.SIM_PROXY_VERBOSE) console.log('[ar-drone-proxy] connected to server', url); });
    this.ws.on('message', (m) => {
      try {
        const data = JSON.parse(m);
        // server sends telemetry messages with type 'telemetry' and payload
        if (data && data.type === 'telemetry' && data.payload) {
          // emit navdata event expected by controller
          this.emit('navdata', { demo: { velocity: { x: data.payload.vx || 0, y: data.payload.vy || 0 }, rotation: { yaw: data.payload.yawRate || 0 } }, raw: data.payload });
        } else if (data && data.type === 'snapshot') {
          this.emit('navdata', data.payload);
        }
      } catch (e) {
        // ignore
      }
    });
    this.ws.on('close', () => { this.connected = false; console.log('[ar-drone-proxy] disconnected from server'); setTimeout(()=>this._connect(), 1000); });
    this.ws.on('error', (err) => { if (process.env.SIM_PROXY_VERBOSE) console.log('[ar-drone-proxy] ws error', err && err.message); });
  }

  _sendCommand(name, val) {
    const msg = JSON.stringify({ type:'command', cmd: name, value: val });
    if (process.env.SIM_PROXY_VERBOSE) console.log('[ar-drone-proxy] sendCommand', name, val, 'connected?', this.connected);
    if (this.connected) this.ws.send(msg);
  }

  // ar-drone minimal API
  disableEmergency() { /* no-op */ }
  ftrim() { this._sendCommand('ftrim'); }
  takeoff() { this._sendCommand('takeoff'); }
  land() { this._sendCommand('land'); }
  stop() { this._sendCommand('stop'); }
  front(v) { this._sendCommand('front', v); }
  back(v) { this._sendCommand('back', v); }
  left(v) { this._sendCommand('left', v); }
  right(v) { this._sendCommand('right', v); }
  clockwise(v) { this._sendCommand('clockwise', v); }
  counterClockwise(v) { this._sendCommand('counterClockwise', v); }
}

module.exports = {
  createClient: function() { return new ProxyClient(); }
};
